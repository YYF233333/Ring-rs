# Visual Novel Engine 开发路线图

> 本文档定义了项目的具体执行计划，遵循 PLAN.md 中的架构约束。

---

## 项目当前状态

### ✅ 已完成模块

1. **vn-runtime 核心运行时**
   - ✅ 脚本解析器（Parser）：支持完整语法规范，50+ 测试用例
   - ✅ AST 定义：完整的脚本节点类型
   - ✅ Command 定义：Runtime → Host 通信协议
   - ✅ RuntimeInput 定义：Host → Runtime 输入模型
   - ✅ WaitingReason 定义：显式等待状态模型
   - ✅ RuntimeState 定义：可序列化的运行时状态
   - ✅ Engine（VNRuntime）：核心执行引擎
   - ✅ Executor：AST 节点到 Command 的转换
   - ✅ 错误处理：完整的错误类型和错误信息

### 🚧 待开发模块

1. **host 适配层（macroquad）**
   - ⏳ 窗口与主循环
   - ⏳ 资源管理系统
   - ⏳ 渲染系统
   - ⏳ 输入处理
   - ⏳ Command 执行器
   - ⏳ Runtime 集成
   - ⏳ 过渡效果实现
   - ⏳ 音频系统

---

## 开发阶段规划

### 阶段 1：基础框架搭建（Foundation）

**目标**：建立 Host 层的基础架构，能够启动窗口并运行主循环。

**任务清单**：

1. **窗口初始化**
   - [x] 配置 macroquad 窗口参数（分辨率、标题等）
   - [x] 实现基本的窗口生命周期管理
   - [x] 添加窗口关闭处理

2. **主循环框架**
   - [x] 实现 `update()` 和 `draw()` 函数
   - [x] 建立帧率控制机制
   - [x] 添加基本的调试信息显示（FPS、状态等）

3. **项目结构组织**
   - [x] 创建模块结构（`resources`, `renderer`, `input`, `command_executor` 等）
   - [x] 定义核心数据结构（`HostState`, `ResourceManager` 等）
   - [x] 建立错误处理机制

**验收标准**：
- ✅ 能够启动窗口并显示空白画面
- ✅ 主循环稳定运行，无崩溃
- ✅ 代码结构清晰，模块划分合理

**状态**：✅ **已完成**（2024年）

**预计工作量**：1-2 天

---

### 阶段 2：资源管理系统（Resource Management）

**目标**：实现图片和音频资源的加载、缓存和管理。

**任务清单**：

1. **资源管理器设计**
   - [x] 定义 `ResourceManager` 结构
   - [x] 实现资源缓存机制（HashMap 存储已加载资源）
   - [x] 实现资源路径解析（相对路径 → 绝对路径）

2. **图片资源加载**
   - [x] 使用 macroquad 的 `load_texture()` 加载图片
   - [x] 实现异步加载机制（或阻塞加载 + 加载状态）
   - [x] 添加资源加载错误处理
   - [x] 实现资源预加载功能（可选）

3. **音频资源加载**
   - [x] 使用 macroquad 的音频 API 加载音频文件
   - [x] 实现 BGM 和 SFX 的资源管理
   - [x] 添加音频格式支持检查

4. **资源生命周期管理**
   - [x] 实现资源释放机制
   - [x] 添加资源引用计数（可选，用于优化）

**验收标准**：
- ✅ 能够从文件系统加载图片和音频
- ✅ 资源缓存正常工作，避免重复加载
- ✅ 资源加载失败时有清晰的错误提示

**状态**：✅ **已完成**（2024年）

**预计工作量**：2-3 天

---

### 阶段 3：渲染系统 - 基础（Rendering - Basic）

**目标**：实现背景、角色立绘和文本的基础渲染。

**任务清单**：

1. **渲染器架构**
   - [ ] 定义 `Renderer` 结构
   - [ ] 实现渲染状态管理（当前背景、可见角色列表等）
   - [ ] 建立渲染层顺序（背景 → 角色 → UI → 文本）

2. **背景渲染**
   - [ ] 实现 `Command::ShowBackground` 的渲染
   - [ ] 实现背景图片的缩放和居中显示
   - [ ] 支持不同分辨率背景的自适应

3. **角色立绘渲染**
   - [ ] 实现 `Command::ShowCharacter` 的渲染
   - [ ] 实现位置映射（Position enum → 屏幕坐标）
   - [ ] 实现角色立绘的显示/隐藏
   - [ ] 支持多个角色同时显示

4. **文本渲染**
   - [ ] 实现 `Command::ShowText` 的渲染
   - [ ] 集成字体加载（使用 `assets/fonts/` 中的字体）
   - [ ] 实现文本对话框 UI（背景框、角色名显示等）
   - [ ] 支持中文字符渲染
   - [ ] 实现文本换行和自动滚动

5. **章节标记渲染**
   - [ ] 实现 `Command::ChapterMark` 的渲染
   - [ ] 设计章节过渡动画 UI

**验收标准**：
- 能够正确显示背景图片
- 能够正确显示角色立绘（支持多个位置）
- 能够正确显示对话文本（含角色名）
- 渲染性能稳定（60 FPS）

**预计工作量**：3-4 天

---

### 阶段 4：输入处理（Input Handling）

**目标**：实现用户输入采集并转换为 RuntimeInput。

**任务清单**：

1. **输入采集**
   - [ ] 使用 macroquad 的输入 API 采集鼠标点击
   - [ ] 采集键盘输入（空格键、回车键等用于点击）
   - [ ] 实现输入事件队列

2. **输入转换**
   - [ ] 将鼠标点击转换为 `RuntimeInput::Click`
   - [ ] 实现选择分支的鼠标交互
   - [ ] 将选择操作转换为 `RuntimeInput::ChoiceSelected`

3. **输入状态管理**
   - [ ] 实现输入防抖（避免重复触发）
   - [ ] 根据 `WaitingReason` 决定是否处理输入
   - [ ] 实现输入反馈（点击动画等）

**验收标准**：
- 点击屏幕能够触发对话推进
- 选择分支能够正确响应鼠标点击
- 输入处理与 Runtime 状态同步

**预计工作量**：1-2 天

---

### 阶段 5：Command 执行器（Command Executor）

**目标**：实现完整的 Command 执行逻辑，连接 Runtime 和 Host。

**任务清单**：

1. **执行器架构**
   - [ ] 定义 `CommandExecutor` 结构
   - [ ] 实现 Command 分发机制（match 所有 Command 变体）

2. **基础 Command 执行**
   - [ ] `ShowBackground` → 调用渲染器
   - [ ] `ChangeScene` → 调用渲染器（与 ShowBackground 类似）
   - [ ] `ShowCharacter` → 调用渲染器
   - [ ] `HideCharacter` → 调用渲染器
   - [ ] `ShowText` → 调用渲染器
   - [ ] `PresentChoices` → 渲染选择分支 UI
   - [ ] `ChapterMark` → 触发章节过渡动画

3. **音频 Command 执行**
   - [ ] `PlayBgm` → 播放背景音乐（支持循环）
   - [ ] `StopBgm` → 停止背景音乐（支持淡出）
   - [ ] `PlaySfx` → 播放音效

4. **UI 动画 Command 执行**
   - [ ] `UIAnimation` → 触发全局 UI 动画

5. **执行状态管理**
   - [ ] 跟踪当前执行的 Command
   - [ ] 处理 Command 执行失败的情况

**验收标准**：
- 所有 Command 类型都能正确执行
- Command 执行与渲染系统正确集成
- 执行错误有适当的错误处理

**预计工作量**：2-3 天

---

### 阶段 6：Runtime 集成（Runtime Integration）

**目标**：将 Runtime 与 Host 层完整集成，实现完整的游戏循环。

**任务清单**：

1. **Runtime 初始化**
   - [ ] 实现脚本文件加载（从 `assets/scripts/` 读取）
   - [ ] 使用 Parser 解析脚本
   - [ ] 创建 VNRuntime 实例

2. **主循环集成**
   - [ ] 在 `update()` 中调用 `runtime.tick(input)`
   - [ ] 处理 `WaitingReason`，决定何时采集输入
   - [ ] 处理 `WaitForTime`，实现时间等待机制

3. **状态同步**
   - [ ] 根据 `WaitingReason` 更新输入处理状态
   - [ ] 实现选择分支 UI 的显示/隐藏
   - [ ] 处理脚本执行完毕的情况

4. **错误处理**
   - [ ] 处理 Runtime 返回的错误
   - [ ] 实现错误显示（日志或 UI 提示）

5. **基础测试**
   - [ ] 使用 `assets/scripts/demo.md` 进行端到端测试
   - [ ] 验证对话、选择分支、背景切换等基本功能

**验收标准**：
- 能够加载并执行脚本文件
- 游戏循环稳定运行
- 基本功能（对话、选择、背景切换）正常工作

**预计工作量**：2-3 天

---

### 阶段 7：过渡效果实现（Transition Effects）

**目标**：实现 dissolve、fade、rule 等过渡效果。

**任务清单**：

1. **过渡效果系统架构**
   - [ ] 定义 `TransitionManager` 结构
   - [ ] 实现过渡效果状态机（开始 → 进行中 → 结束）
   - [ ] 实现过渡效果队列（支持多个效果叠加）

2. **基础过渡效果**
   - [ ] `dissolve`：淡入淡出（alpha 插值）
   - [ ] `Dissolve(duration)`：指定时长的淡入淡出
   - [ ] `fade`：渐隐渐显（与 dissolve 类似）
   - [ ] `Fade(duration)`：指定时长的渐隐渐显

3. **高级过渡效果**
   - [ ] `rule`：遮罩过渡（使用 rule 图片）
   - [ ] 实现 rule 图片的加载和应用
   - [ ] 支持 rule 的 duration 和 reversed 参数

4. **过渡效果应用**
   - [ ] 背景切换时应用过渡效果
   - [ ] 角色显示/隐藏时应用过渡效果
   - [ ] UI 动画时应用过渡效果

5. **性能优化**
   - [ ] 确保过渡效果不影响帧率
   - [ ] 实现过渡效果的提前结束（点击跳过）

**验收标准**：
- 所有过渡效果都能正确显示
- 过渡效果流畅（60 FPS）
- 支持在过渡过程中点击跳过

**预计工作量**：3-4 天

---

### 阶段 8：音频系统完善（Audio System）

**目标**：完善音频播放功能，支持 BGM 和 SFX。

**任务清单**：

1. **音频管理器**
   - [ ] 定义 `AudioManager` 结构
   - [ ] 实现 BGM 和 SFX 的独立管理
   - [ ] 实现音频资源缓存

2. **BGM 播放**
   - [ ] 实现循环播放
   - [ ] 实现淡入淡出效果
   - [ ] 实现 BGM 切换时的平滑过渡

3. **SFX 播放**
   - [ ] 实现音效播放（不循环）
   - [ ] 支持多个 SFX 同时播放
   - [ ] 实现音量控制

4. **音频控制**
   - [ ] 实现音量设置（BGM / SFX 独立）
   - [ ] 实现静音功能
   - [ ] 实现音频暂停/恢复

**验收标准**：
- BGM 能够正常播放和循环
- SFX 能够正常播放
- 音频控制功能正常工作

**预计工作量**：2-3 天

---

### 阶段 9：UI 完善与优化（UI Polish）

**目标**：完善用户界面，提升用户体验。

**任务清单**：

1. **选择分支 UI**
   - [ ] 实现选择分支的视觉样式（按钮、高亮等）
   - [ ] 实现鼠标悬停效果
   - [ ] 支持键盘导航（方向键选择）

2. **文本对话框优化**
   - [ ] 优化文本显示效果（阴影、描边等）
   - [ ] 实现文本逐字显示效果（可选）
   - [ ] 优化对话框样式

3. **章节过渡 UI**
   - [ ] 实现章节标题显示动画
   - [ ] 设计章节过渡的视觉效果

4. **调试信息**
   - [ ] 实现调试模式（显示 FPS、状态等）
   - [ ] 实现日志系统

**验收标准**：
- UI 美观且易用
- 交互反馈清晰
- 调试工具可用

**预计工作量**：2-3 天

---

### 阶段 10：测试与优化（Testing & Optimization）

**目标**：全面测试系统，修复 bug，优化性能。

**任务清单**：

1. **功能测试**
   - [ ] 使用完整脚本进行端到端测试
   - [ ] 测试所有 Command 类型
   - [ ] 测试所有过渡效果
   - [ ] 测试选择分支和跳转

2. **性能优化**
   - [ ] 优化资源加载（预加载、异步加载）
   - [ ] 优化渲染性能（减少 draw call）
   - [ ] 优化内存使用（资源释放）

3. **错误处理完善**
   - [ ] 添加资源加载失败的降级处理
   - [ ] 添加脚本解析错误的友好提示
   - [ ] 实现错误恢复机制

4. **文档完善**
   - [ ] 编写 Host 层的使用文档
   - [ ] 添加代码注释
   - [ ] 更新 README

**验收标准**：
- 所有功能正常工作
- 性能稳定（60 FPS）
- 错误处理完善
- 文档完整

**预计工作量**：3-4 天

---

## 总体时间估算

| 阶段 | 预计工作量 | 优先级 |
|------|-----------|--------|
| 阶段 1：基础框架搭建 | 1-2 天 | 🔴 高 |
| 阶段 2：资源管理系统 | 2-3 天 | 🔴 高 |
| 阶段 3：渲染系统 - 基础 | 3-4 天 | 🔴 高 |
| 阶段 4：输入处理 | 1-2 天 | 🔴 高 |
| 阶段 5：Command 执行器 | 2-3 天 | 🔴 高 |
| 阶段 6：Runtime 集成 | 2-3 天 | 🔴 高 |
| 阶段 7：过渡效果实现 | 3-4 天 | 🟡 中 |
| 阶段 8：音频系统完善 | 2-3 天 | 🟡 中 |
| 阶段 9：UI 完善与优化 | 2-3 天 | 🟢 低 |
| 阶段 10：测试与优化 | 3-4 天 | 🟡 中 |

**总计**：约 21-30 天（按每天 4-6 小时计算）

---

## 开发原则

1. **遵循 PLAN.md 约束**
   - Runtime 与 Host 严格分离
   - Command 驱动模式
   - 显式状态管理

2. **测试驱动开发**
   - 每个模块都要有单元测试
   - 关键功能要有集成测试
   - 修复 bug 后补充回归测试

3. **渐进式开发**
   - 先实现核心功能，再完善细节
   - 每个阶段都要有可运行的版本
   - 及时集成和测试

4. **代码质量**
   - 清晰的模块划分
   - 完善的文档注释
   - 遵循 Rust 最佳实践

---

## 下一步行动

**立即开始**：阶段 1 - 基础框架搭建

1. 创建 Host 层的模块结构
2. 实现基本的 macroquad 窗口初始化
3. 建立主循环框架

---

> **注意**：本路线图是动态文档，会根据实际开发进度和需求变化进行调整。
